#### JavaScript是如何执行的

***

语言分位编译型语言和解释器语言，而JavaScript就是解释型语言

编译步骤分为：词法分析->语法分析->语义分析->中间代码生成->代码优化和字节码生成。

解释步骤分为：词法分析->语法分析->语法树生成，就可以开始解释执行了。

具体过程：

1. 词法分析：将源代码的字符流读入，转换成词法单元，并构建词法单元表

2. 语法分析：利用词法分析创建的此法单元，构建语法分析树，树的每个子节点都表示语句的运算分量

3. 预编译：当JavaScript引擎执行脚本时，它会在预编译期对所有声明的变量和函数进行处理，这也是变量提升和函数提升的产生原因

4. 解释执行：JavaScript 引擎是严格按着作用域机制（scope）来执行的，遵守词法作用域的静态作用域，即变量是在定义时位置决定的，有函数作用域，无块状作用域。

   JavaScript 引擎通过作用域链（scope chain）把多个嵌套的作用域串连在一起，并借助这个链条帮助 JavaScript 解释器检索变量的值。

#### V8与JIT

***

我们常说的 V8 是 Google 发布的开源 JavaScript 引擎，采用 C++ 编写。SpiderMonkey（Mozilla，基于 C）、Rhino（Mozilla，基于 Java），而 Nodejs 依赖于 V8 引擎开发，接下来的内容是 JavaScript 在 V8 引擎中的运行状态，而类似的 JavaScript 现代引擎对于这些实现大同小异。

**JavaScript 是解释型语言且`弱类型`，**在生成 AST 之后，就开始一边解释，一边执行，但是有个**弊端，当某段代码被多次执行时，它就有了可优化的空间（比如类型判断优化），而不用一次次的去重复之前的解释执行。**
编译型语言如 JAVA，可以在执行前就进行优化编译，但是这会耗费大量的时间，显然不适用于 Web 交互。

**于是就有了，JIT（Just-in-time），JIT 是两种模式的混合。**

1.在 JavaScript 引擎中增加一个监视器（也叫分析器）。监视器监控着代码的运行情况，记录代码一共运行了多少次、如何运行的等信息，如果同一行代码运行了几次，这个代码段就被标记成了 “warm”，如果运行了很多次，则被标记成 “hot”。

2.（基线编译器）如果一段代码变成了 “warm”，那么 JIT 就把它送到基线编译器去编译，并且把编译结果存储起来。比如，监视器监视到了，某行、某个变量执行同样的代码、使用了同样的变量类型，那么就会把编译后的版本，替换这一行代码的执行，并且存储。

3.（优化编译器）如果一个代码段变得 “hot”，监视器会把它发送到优化编译器中。生成一个更快速和高效的代码版本出来，并且存储。例如：循环加一个对象属性时，假设它是 INT 类型，优先做 INT 类型的判断

4.（去优化）可是对于 JavaScript 从来就没有确定这么一说，前 99 个对象属性保持着 INT 类型，可能第 100 个就没有这个属性了，那么这时候 JIT 会认为做了一个错误的假设，并且把优化代码丢掉，执行过程将会回到解释器或者基线编译器，这一过程叫做去优化。