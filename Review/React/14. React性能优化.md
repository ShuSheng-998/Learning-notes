## SCU

* `shouldComponentUpdate()`
* `PureComponent`和`React.memo`（函数组件中的PureComponent）
* `immutable.js`

## shoudComponentUpdate

![image-20210329092217716](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210329092217716.png)

* **在默认情况下，父组件更新，子组件也会无条件更新**（state, props）

  1. 子组件要重写SCU

     ```jsx
     shouldComponentUpdate(nextProps, nextState) {
             if (nextProps.text !== this.props.text
                 || nextProps.length !== this.props.length) {
                 return true // 可以渲染
             }
             return false // 不重复渲染
         }
     ```

* SCU不一定要每次都使用，——需要的时候才优化，不造成卡顿的组件可以不适用

* SCU一定要配合不可变值使用，因为，如果未使用，现在的state值被修改了，下一次的和现在的一样，这个比较毫无意义

  ```jsx
  // 增加 shouldComponentUpdate
      shouldComponentUpdate(nextProps, nextState) {
          // _.isEqual 做对象或者数组的深度比较（一次性递归到底）
          if (_.isEqual(nextProps.list, this.props.list)) {
              // 相等，则不重复渲染
              return false
          }
          return true // 不相等，则渲染
      }
  ```

### PureComponent

* **在SCU中实现了浅比较**
* 浅比较适用于大部分情况（尽量不做深比较）

* 使用：`Class`继承`React.PureComponent`

  ```jsx
  class List extends React.PureComponent {
  	shouldComponentUpdate() {/*浅比较*/}//自动实现
     
  }
  ```

### React.memo()

![image-20210329100726710](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210329100726710.png)