## 1. tcp连接的特点

- 提供面向连接的，可靠的字节流服务
- 为上层应用层提供服务，不关心具体传输的内容是什么，也不知道是二进制流，还是ascii字符。

## 2. tcp的可靠性如何保证

- 分块传送：数据被分割成**最合适的**数据块（UDP的数据报长度不变）
- 等待确认：通过定时器等待接收端发送确认请求，收不到确认则重发
- 确认回复：收到确认后发送确认回复(不是立即发送，通常推迟几分之一秒)
- 数据校验：保持首部和数据的校验和，检测数据传输过程有无变化
- 乱序排序：接收端能重排序数据，以正确的顺序交给应用端
- 重复丢弃：接收端能丢弃重复的数据包
- 流量缓冲：两端有固定大小的缓冲区（滑动窗口），防止速度不匹配丢数据

## 3. tcp的首部格式

### 3.1 宏观位置

![img](https://user-gold-cdn.xitu.io/2018/9/24/1660a9b6dee9caf5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- 从应用层->传输层->网络层->链路层，每经过一次都会在报文中增加相应的首部。
- TCP数据被封装在IP数据报中

### 3.2 首部格式

![img](https://user-gold-cdn.xitu.io/2018/9/24/1660aa15acdcc530?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- tcp首部数据通常包含20个字节（不包括任选字段）

- 第1-2两个字节：源端口号

- 第3-4两个字节：目的端口号

  > 源端口号+ip首部中的源ip地址+目的端口号+ip首部中的目的ip地址，唯一的确定了一个tcp连接。对应编码级别的socket。

- 第5-8四个字节：32位序号。tcp提供全双工服务，两端都有各自的序号。**编号：解决网络包乱序的问题**

  > 序号如何生成：不能是固定写死的，否则断网重连时序号重复使用会乱套。tcp基于时钟生成一个序号，每4微秒加一，到2^32-1时又从0开始

- 第9-12四个字节：32位确认序列号。上次成功收到数据字节序号加1，ack为1才有效。**确认号：解决丢包的问题**

- 第13位字节：首部长度。因为任选字段长度可变

- 后面6bite：保留

- 随后6bite：标识位。**控制各种状态**

- 第15-16两个字节：窗口大小。接收端期望接收的字节数。**解决流量控制的问题**

- 第17-18两个字节：校验和。由发送端计算和存储，由接收端校验。**解决数据正确性问题**

- 第19-20两个字节：紧急指针

### 3.3 标识位说明

- URG：为1时，表示紧急指针有效
- ACK：确认标识，连接建立成功后，总为1。为1时确认号有效
- PSH：接收方应尽快把这个报文交给应用层
- RST：复位标识，重建连接
- SYN：建立新连接时，该位为0
- FIN：关闭连接标识

## 4.三次握手

![img](https://user-gold-cdn.xitu.io/2018/9/24/1660af5dec5b3e88?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

1. 服务器端在客户端发送连接请求之前会建立传输控制模块TCB，并进入`listen`监听状态。
2. 客户端在发起连接请求时，会建立传输控制模块TCB，发送请求后，会进入`SYN-SENT`同步已发送状态，请求的内容是，兄弟，我是客户端，我的同步号为1，初始序列号为`x`，请求与你建立连接（同步），会消耗掉一个序号
3. 服务端在收到连接请求后，会发送确认报文。哥们，我接受到了请求，我的SYN同步号也为1，大ACK确认标志位位1，确认号ack为`x+1`，下个序号为`y`。并进入`SYN-RCVD`请求已接受状态。
4. 客户端在收到确认请求报文后，会再次发送确认报文，我的SYN同步号也为1，大ACK确认标志位位1，确认号ack为`y+1`，下个序号为`x+1`。并进入`ESTABLISHED`建立状态
5. 服务端接受到最后的确认报文后进入`ESTABLISHED`建立状态

### 为什么是三次握手

1. 不是两次

   ```
   如果只是两次握手，客户端在发送一次请求后，如果这个请求在网络中阻塞了，客户端长时间未收到来自服务端的确认报文，就会认为这个请求报文丢失了，然后超时重传，重传成功，然后服务端业接受到消息，建立连接成功数据发送完毕。
   现在假设一种情况：第一次发送的请求报文并没有丢失，它最后到达了服务器端，服务器以为客户端又发送了请求，就会发送确认报文，而客户端现在并不需要传输数据，于是就不会理财服务器端，丹服务器端保留了此次请求的TCB控制模块的资源，就造成了资源浪费
   ```

2. 不是四次？

   ```
   没必要，连接在第三次握手就解决了可能出现的问题
   ```

## 5.四次挥手

![img](https://user-gold-cdn.xitu.io/2018/9/24/1660b064e8802dba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

1. 客户端数据传输完毕，发送连接释放报文。内容是，兄弟，我发完了，我的`终止号FIN`是1，序号 `seq`为u

（它等于已传送过的最后一个字节的序号加一），消耗点一个序号，然后进入`终止等待状态1:FIN-WAIT-1`

2. 服务端收到消息后，发出确认释放报文。内容是，好的，老铁，我的`ACK=1`，序列号是`v`,确认号是`u+1`。

然后从`ESTABLISHED`装填就进入`CLOSED-WAIT`状态。

3. 客户端收到服务端的确认释放报文后，进入`终止等待状态2：FIN-WAIT-2`。等待服务端发送的连接释放报文

   

   至此，TCP处于半关闭状态，只是A到B的传输失效了，B还能向A发送数据

   

4. 在服务端发送完数据后，上层的应用程序就会告诉TCP释放连接。服务端就会发送连接释放报文，并进入`最后等待状态：LAST-WAIT`。内容是，兄弟，我也发完了，我的我的`ACK=1`，`FIN=1`，序列号是`v+1`,确认号是`u+1`。

5. 客户端收到服务端发送的最后释放报文后，会发送确认释放报文，并进入`TIME-WAIT时间等待状态`，在等待两倍的最长报文段寿命的时间后`2MSL`,进入`CLOSED`状态
6. 服务端在收到确认释放报文后，会从最后等待状态进入`CLOSED`状态

### 为什么是四次挥手

一、

* 设想一个场景，最后客户端发送的确认报文丢失了，服务端没有收到，服务端就会一致处于`LAST-ACK`状态，不能正确进入`CLOSED`状态，导致TCB资源不能回收
* 这时候服务端可以重新发送连接释放报文给客户端
* 这个等待时间就是为了防止这种情况发生，让服务端重新发送ack
* 总结：预留足够的时间给接收端收ack。同时保证，这个连接不会和后续的连接乱套（有些路由器会缓存数据包）

二、

* 2MSL防止已失效的连接请求再次出现在此次连接中。2MSL后所有的超时报文都消失了

三、

或许会有疑问，为什么服务端的ACK报文和FIN报文都是分开发送的，但是在三次握手的时候却是ACK报文和SYN报文是一起发送的，因为在三次握手的过程中，当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是在关闭连接时，当服务端接收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，你发的FIN报文我收到了，只有等到服务端所有的数据都发送完了，才能发送FIN报文，因此ACK报文和FIN报文不能一起发送。所以断开连接的时候才需要四次挥手来完成。
